package com.sarp.lambda.optional;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.Scanner;
import java.util.function.Supplier;
import java.util.stream.Collectors;
public class MapVsFlatMap {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
        List<Integer> squaredNumbers = numbers.stream()
                .map(n -> n * n)
                .collect(Collectors.toList());

        List<String> listOfStrings = Arrays.asList("Hello", "World");
        List<String> listOfChars = listOfStrings.stream()
                .flatMap(str -> Arrays.stream(str.split("")))
                .collect(Collectors.toList());
        System.out.println(squaredNumbers);
        System.out.println(listOfChars);

        Supplier<Optional<String>> supplier = () -> {
            System.out.print("Enter a string:");
            return Optional.of((new Scanner(System.in)).nextLine());
        };
        String s = null;
        Optional<String> os = Optional.ofNullable(s)
                .or(supplier);
        if (os.isPresent())
            System.out.println(os.get());
        //
//        Main Differences
//        Transformation vs. Flattening: map transforms each element individually, whereas flatMap both transforms and flattens, turning each element into zero or more elements in the resulting stream.
//
//                Output: The result of the map operation is a stream consisting of the transformed elements. In contrast, flatMap results in a single flattened stream from all the streams generated by the transformation function.
//
//                Use Cases: Use map for simple transformations of elements. Use flatMap when each element can lead to multiple elements in the result (e.g., splitting a string into characters, or when working with nested collections or streams).
//

    }
}
